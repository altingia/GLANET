/**
 * @author Burcak Otlu
 * Jan 30, 2014
 * 12:05:22 PM
 * 2014
 *
 * 
 */
package rsat;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.List;

import javax.xml.rpc.ServiceException;

import RSATWS.MatrixScanRequest;
import RSATWS.MatrixScanResponse;
import RSATWS.RSATWSPortType;
import RSATWS.RSATWebServicesLocator;
import auxiliary.FileOperations;

import common.Commons;



public class RSATMatrixScanClient {

	/**
	 * 
	 */
	public RSATMatrixScanClient() {
		// TODO Auto-generated constructor stub
	}
	
	public static String readAllfromFile(String inputFileName){
		FileReader fileReader = null;
		BufferedReader bufferedReader = null;
		
		String strLine = null;
		String all = "";
		
		
		try {
			fileReader = new FileReader(inputFileName);
			bufferedReader = new BufferedReader(fileReader);
			
			while((strLine = bufferedReader.readLine())!=null){
				all = all + strLine +System.getProperty("line.separator");
				
			}
			
			bufferedReader.close();
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		return all;
		
	}
	
	
	
	
	//direction does not matter
	//start is always less than end
	public static boolean constainsSNP(int start,int end,int snpPosition){
			if (snpPosition <= end && snpPosition>=start){
				return true;
			}
			
		
		return false;
	}
	
	public static int getOneBasedPeakStart(String bestPeakResultLine){
//		peak_BCLAF1M33_GM12878_170862295_170862544_BCLAF1M33_hsa05016 	site 	matrix-scan_2014-03-03.2 	R 	108 	117 	GCCGGAAGTG 	7.7 	1.7e-06 	-13.269 	5.762 	1 	1
//		int indexofFirstTab = bestPeakResultLine.indexOf('\t');
//		
//		String peak = bestPeakResultLine.substring(0, indexofFirstTab);
//		
//		int indexofFirstUnderscore 	= peak.indexOf('_');
//		int indexofSecondUnderscore = peak.indexOf('_',indexofFirstUnderscore+1);
//		int indexofThirdUnderscore 	= peak.indexOf('_',indexofSecondUnderscore+1);
//		int indexFourthUnderscore 	= peak.indexOf('_',indexofThirdUnderscore+1);
//		
//		return Integer.parseInt(peak.substring(indexofThirdUnderscore+1, indexFourthUnderscore));
	
		//example
		//gi|224589818:170862228-170862467	site	matrix-scan-matrix_2014-04-14.5	R	37	45	ACAGAGCCG	4.7	5.6e-04	-7.490	3.253	1	1
		
		int indexofFirstColon = bestPeakResultLine.indexOf(':');
		int indexofFirstHyphen = bestPeakResultLine.indexOf('-');
					
		return Integer.parseInt(bestPeakResultLine.substring(indexofFirstColon+1, indexofFirstHyphen));

	}
	
	
	public static int getOneBasedSNPStart(String bestSNPResultLine){
//		example snp result line
//		snp_chr6_170862335_BCLAF1M33_hsa05016 	site 	matrix-scan_2014-03-03.5 	D 	15 	28 	GGCTGCGCCTGCGG 	4.8 	4.2e-06 	-12.391 	5.381 	1 	1
		
//		int indexofFirstTab = bestSNPResultLine.indexOf('\t');
//		
//		String snp = bestSNPResultLine.substring(0, indexofFirstTab);
//		
//		int indexofFirstUnderscore = snp.indexOf('_');
//		int indexofSecondUnderscore = snp.indexOf('_',indexofFirstUnderscore+1);
//		int indexofThirdUnderscore = snp.indexOf('_',indexofSecondUnderscore+1);
//		
//		return Integer.parseInt(snp.substring(indexofSecondUnderscore+1, indexofThirdUnderscore));
		
		//example snp result line
		//gi|224589818:170862322-170862350	site	matrix-scan-matrix_2014-04-11.5	D	13	21	ACGGCTGCG	3.5	3.7e-03	-5.602	2.433	2	2		
		int indexofFirstColon = bestSNPResultLine.indexOf(':');
		int indexofFirstHyphen = bestSNPResultLine.indexOf('-');
					
		return Integer.parseInt(bestSNPResultLine.substring(indexofFirstColon+1, indexofFirstHyphen)) + Commons.NUMBER_OF_BASES_BEFORE_SNP_POSITION;

		

	}
	
	public static void getPeakSequenceStartandEnd(PeakSequence peakSequence,String peakResultLine){
		
		//example
		//gi|224589818:170862228-170862467	site	matrix-scan-matrix_2014-04-14.5	R	37	45	ACAGAGCCG	4.7	5.6e-04	-7.490	3.253	1	1
		int indexofFirstTab 	= peakResultLine.indexOf('\t');
		int indexofSecondTab 	= peakResultLine.indexOf('\t',indexofFirstTab+1);
		int indexofThirdTab 	= peakResultLine.indexOf('\t',indexofSecondTab+1);
		int indexofFourthTab	= peakResultLine.indexOf('\t',indexofThirdTab+1);
		int indexofFifthTab 	= peakResultLine.indexOf('\t',indexofFourthTab+1);
		int indexofSixthTab 	= peakResultLine.indexOf('\t',indexofFifthTab+1);
		
		peakSequence.setStart(Integer.parseInt(peakResultLine.substring(indexofFourthTab+1, indexofFifthTab)));
		peakSequence.setEnd(Integer.parseInt(peakResultLine.substring(indexofFifthTab+1, indexofSixthTab)));
		
	}

	
	public static boolean peakResultLineContainsSNPPosition(String snpResultLine,String peakResultLine){
		int snpStartOneBased = 0;
		int peakStartOneBased = 0;
		int snpPositionWithRespectoPeakSequence = 0;
		
		PeakSequence peakSequence= new PeakSequence();
		
		
		snpStartOneBased = getOneBasedSNPStart(snpResultLine);
		peakStartOneBased = getOneBasedPeakStart(peakResultLine);
		
		snpPositionWithRespectoPeakSequence = snpStartOneBased - peakStartOneBased +1;
		
		getPeakSequenceStartandEnd(peakSequence,peakResultLine);
		
		return constainsSNP(peakSequence.getStart(), peakSequence.getEnd(), snpPositionWithRespectoPeakSequence);
		
	}
	
	//Among the reference result lines 
	//get the best reference line containing snp position
	public static Result getBestReferenceResultLineContainigSNPPosition(String description, String snpResult,BufferedWriter bufferedWriter) throws IOException{
		
		String snpResultLine = null;
		String bestSNPResultLine =null;
		
		int indexofSharpinSNPResult;
		int indexofNewLineinSNPResult;
		int indexofNextNewLineinSNPResult;
		
		
		int indexofFirstTab;
		int indexofSecondTab;
		int indexofThirdTab;
		int indexofFourthTab;
		int indexofFifthTab;
		int indexofSixthTab;
		int indexofSeventhTab;
		int indexofEigthTab;
		int indexofNinethTab;
		
		char direction = ' ';
		int start = 0;
		int end = 0;
		double pValue = 0;
		String sequence = null;
		
		int countforSNPResultLine = 0;
		
		Result result = new Result();
	
		indexofSharpinSNPResult = snpResult.indexOf('#');
		indexofNewLineinSNPResult = snpResult.indexOf('\n',indexofSharpinSNPResult+1);
		indexofNextNewLineinSNPResult = snpResult.indexOf('\n',indexofNewLineinSNPResult+1);
		
		
		bufferedWriter.write("description" + "\t" + "direction" + "\t" + "start" + "\t" + "end" + 	"\t" + "sequence" + "\t" + "pValue" + "\t" + "logRatio" + System.getProperty("line.separator"));
		
		
		do{
			
			snpResultLine = snpResult.substring(indexofNewLineinSNPResult+1,indexofNextNewLineinSNPResult);
			
			if(snpResultLine.startsWith(";")){
				//Not a valid snp result line 
				break;
			}
			
			//check whether there is no snp result or there is no snp result containing snp position
			//if there is a break countforSNPResultLine will remain zero means that there is no snp result
			//else countforSNPResultLine will be nonzero means there is at least one snp result 
			countforSNPResultLine++;
			
			indexofFirstTab 	= snpResultLine.indexOf('\t');
			indexofSecondTab 	= snpResultLine.indexOf('\t',indexofFirstTab+1);
			indexofThirdTab 	= snpResultLine.indexOf('\t',indexofSecondTab+1);
			indexofFourthTab 	= snpResultLine.indexOf('\t',indexofThirdTab+1);
			indexofFifthTab 	= snpResultLine.indexOf('\t',indexofFourthTab+1);
			indexofSixthTab 	= snpResultLine.indexOf('\t',indexofFifthTab+1);
			indexofSeventhTab	= snpResultLine.indexOf('\t',indexofSixthTab+1);
			indexofEigthTab 	= snpResultLine.indexOf('\t',indexofSeventhTab+1);
			indexofNinethTab 	= snpResultLine.indexOf('\t',indexofEigthTab+1);
			
			direction = snpResultLine.substring(indexofThirdTab+1, indexofFourthTab).charAt(0);
			start = Integer.parseInt(snpResultLine.substring(indexofFourthTab+1, indexofFifthTab));
			end = Integer.parseInt(snpResultLine.substring(indexofFifthTab+1, indexofSixthTab));
			sequence = snpResultLine.substring(indexofSixthTab+1,indexofSeventhTab);
			pValue = Double.parseDouble(snpResultLine.substring(indexofEigthTab+1, indexofNinethTab));
			
			
			//in case of next snpResult fetch
			indexofNewLineinSNPResult = indexofNextNewLineinSNPResult;
			indexofNextNewLineinSNPResult = snpResult.indexOf('\n', indexofNewLineinSNPResult+1);
			
		} while(!constainsSNP(start,end,Commons.ONE_BASED_SNP_POSITION));

		
		if(snpResultLine.startsWith(";") && countforSNPResultLine==0){
			bufferedWriter.write("There is no snp result line" + System.getProperty("line.separator"));	
		}else if (snpResultLine.startsWith(";") && countforSNPResultLine!=0){
			bufferedWriter.write("There is NO snp result line containing snp position" + System.getProperty("line.separator"));
		}else {
			bestSNPResultLine = snpResultLine;
			//no need to write this.
			//bufferedWriter.write(direction + "\t" + start + "\t" + end + "\t" + sequence + "\t" + pValue +System.getProperty("line.separator"));
		}
		
		if(bestSNPResultLine!=null){
			bufferedWriter.write(description + "\t"+ direction + "\t" + start + "\t" + end + 	"\t" + sequence + "\t" + pValue + System.getProperty("line.separator"));
		}
		
		result.setpValue(pValue);
		result.setResultLine(bestSNPResultLine);
		
		return result;

	}
	
	
	public static void getBestPeakResultLine(String bestSNPResultLine,String peakResult, BufferedWriter bufferedWriter) throws IOException{
		
		int countforPeakResultLine = 1;
		
		boolean isThereAPeakResultLineContainingSNPPosition = false;

		int indexofSharpinPeakResult = peakResult.indexOf('#');
		int indexofNewLineinPeakResult = peakResult.indexOf('\n',indexofSharpinPeakResult+1);
		int indexofNextNewLineinPeakResult = peakResult.indexOf('\n',indexofNewLineinPeakResult+1);
		
		
		String peakResultLine = peakResult.substring(indexofNewLineinPeakResult+1,indexofNextNewLineinPeakResult);
		String  bestPeakResultLine = null;
		
		if(peakResultLine.startsWith(";")){
			bufferedWriter.write("There is no peak result line" + System.getProperty("line.separator"));	
		}else{
			bestPeakResultLine = peakResultLine;
			bufferedWriter.write("Best peak sequence: " + bestPeakResultLine +System.getProperty("line.separator"));
		}
		
		//if best snp result line and best peak result line are not null
		if(bestSNPResultLine!=null && bestPeakResultLine!=null){
			
			while(!(isThereAPeakResultLineContainingSNPPosition = peakResultLineContainsSNPPosition(bestSNPResultLine,bestPeakResultLine))){
				
				//in case of next peakResult fetch
				indexofNewLineinPeakResult = indexofNextNewLineinPeakResult;
				indexofNextNewLineinPeakResult = peakResult.indexOf('\n',indexofNewLineinPeakResult+1);
				countforPeakResultLine++;
				
				bestPeakResultLine = peakResult.substring(indexofNewLineinPeakResult+1,indexofNextNewLineinPeakResult);
				
				//Not a valid peak result line
				if(bestPeakResultLine.startsWith(";")){
					break;
				}
				
			}//End of while 
			
			//There is a peak result line containing snp position
			if(isThereAPeakResultLineContainingSNPPosition){
				bufferedWriter.write("Peak result line containing snp position at " + countforPeakResultLine + ". peak result line : "   + bestPeakResultLine + System.getProperty("line.separator"));
			}
			//There is no peak result line containing snp position
			else{
				bufferedWriter.write("There is no peak result line containing snp position" + System.getProperty("line.separator"));
				
			}
		}
	}
	
	public static void calculateLogRatioofPValues(Result bestReferenceLineResult, Result bestAlteredLineResult, BufferedWriter bufferedWriter) throws IOException{
		
		double logRatio;
		DecimalFormat df = new DecimalFormat("0.######E0");
		
		double pValueofReferenceSequence = 0;
		double pValueofAlteredSequence = 0;
		
		if (bestReferenceLineResult.getResultLine() != null && bestAlteredLineResult.getResultLine()!= null){
			pValueofReferenceSequence = bestReferenceLineResult.getpValue();
			pValueofAlteredSequence = bestAlteredLineResult.getpValue();
			
			logRatio = Math.log10(pValueofReferenceSequence/pValueofAlteredSequence);
			bufferedWriter.write("log ratio of reference sequence to the altered sequence is : " + df.format(logRatio) + System.getProperty("line.separator"));
		
		}else{
			bufferedWriter.write("log ratio of reference sequence to the altered sequence is : Not Applicable"  + System.getProperty("line.separator"));		
		}
		
		
			
	}

	
	//search for the best snp result line containing snp position among peak result lines
	public static void compareResults(String snpResult, List<String> alteredSNPResults,String peakResult, BufferedWriter bufferedWriter) throws IOException{
				
		Result bestReferenceLineResult = null;
		Result bestAlteredLineResult = null;
		
		String description = "Best reference sequence containing snp position: ";
		//Get best snp result line containing snp position if it exists
		bestReferenceLineResult = getBestReferenceResultLineContainigSNPPosition(description,snpResult,bufferedWriter);
			
		
		//Get best peak result line containing snp position 
		getBestPeakResultLine(bestReferenceLineResult.getResultLine(),peakResult,bufferedWriter);
		
		description = "Best altered sequence containing snp position: ";
		
		//get the best alteredSNPResultLine containing snp position
		for(String alteredSNPResult: alteredSNPResults){
			bestAlteredLineResult =getBestReferenceResultLineContainigSNPPosition(description,alteredSNPResult,bufferedWriter);
			
			calculateLogRatioofPValues(bestReferenceLineResult,bestAlteredLineResult,bufferedWriter);
		}
				
	}

	
	public static void matrixScan(String snpInputFile,List<String> alteredSNPInputFiles,String peakInputFile,String pfmMatricesInputFile,RSATWSPortType proxy,MatrixScanRequest matrixScanRequest,BufferedWriter bufferedWriter){
		try{
		
			
			bufferedWriter.write("********************************************" + System.getProperty("line.separator"));
			//bufferedWriter.write("This script illustrates a request to RSATMatrixScan ..." + System.getProperty("line.separator"));
			bufferedWriter.write("pfmMatricesFile: "  + pfmMatricesInputFile +System.getProperty("line.separator"));

			
//			RSATWebServicesLocator service = new RSATWebServicesLocator();		
//			RSATWSPortType proxy = service.getRSATWSPortType();			
//			MatrixScanRequest matrixScanRequest = new MatrixScanRequest();
				
			String snpSequence = readAllfromFile(snpInputFile);
			String peakSequences = readAllfromFile(peakInputFile);
						
			String sequence_format = "fasta";
			matrixScanRequest.setSequence_format(sequence_format);
			
			String mask = "non-dna";
			//How to set this parameter?
						
			String pfmMatrices = readAllfromFile(pfmMatricesInputFile);
		
			matrixScanRequest.setMatrix(pfmMatrices);
						
			String matrixFormat = "tab";
			matrixScanRequest.setMatrix_format(matrixFormat);
			
			Integer markov     = new Integer (0);
			matrixScanRequest.setMarkov(markov);
				
			String organism = Commons.RSAT_ORGANISM_Homo_sapiens_ensembl_74_GRCh37;
			matrixScanRequest.setOrganism(organism);
			
			String background 	= Commons.RSAT_BACKGROUND_upstream_noorf;
			matrixScanRequest.setBackground(background);
			
			float pseudo_frequencies = 0.01f;
			matrixScanRequest.setBackground_pseudo(new Float(pseudo_frequencies));
			
//			String tmp_background_infile = Commons.RSAT_tmp_background_infile;
//			matrixScanRequest.setTmp_background_infile(tmp_background_infile);
		
			Integer search_strands = new Integer(2);
			matrixScanRequest.setStr(search_strands);
			
			//Although it is set to start
			//It is not set in the called matrixScan
			String origin 		= "start";
			matrixScanRequest.setOrigin(origin);
			
			String offset = "0";
			//how to set this parameter?
			
			Integer verbosity 	= new Integer (1);
			matrixScanRequest.setVerbosity(verbosity);
		
			Integer pseudo_counts 		= new Integer (1);
			matrixScanRequest.setPseudo(pseudo_counts);
						
			Integer score_decimals 	= new Integer (1);
			matrixScanRequest.setDecimals(score_decimals);
			
			String n_treatment	 = "score";
			matrixScanRequest.setN_treatment(n_treatment);
			
			//If you do not set these parameters 
			//they are set to NONE
		
			String[] uth = {"pval 0.1"};
			matrixScanRequest.setUth(uth);
			
						
			matrixScanRequest.setReturn_fields("sites,pval,rank");
			
						
			matrixScanRequest.setSequence(snpSequence);
		
			/*Call the service*/
			//bufferedWriter.write("Matrix-scan: sending request to the server for reference sequence..." + System.getProperty("line.separator"));
			bufferedWriter.write("referenceSequenceFile: "+  snpInputFile + System.getProperty("line.separator"));
			
			MatrixScanResponse snpResponse = proxy.matrix_scan(matrixScanRequest);
				
			/* Process results*/
			//Report the remote command
	//		System.out.println("Command used on the server:"+ response.getCommand());
//			String commandUsedontheServerforSNP = snpResponse.getCommand();
				
			//Report the server file location
	//		System.out.println("Result file on the server::" + System.getProperty("line.separator")+ response.getServer());
//			String resultFileontheServerforSNP = snpResponse.getServer();
			
				
			//Results
			String referenceResult = snpResponse.getClient();
			
			matrixScanRequest.setSequence(peakSequences);
			
			/*Call the service*/
			//bufferedWriter.write("Matrix-scan: sending request to the server for extended peak sequence..." + System.getProperty("line.separator"));
			bufferedWriter.write("extendedPeakSequenceFile: "+  peakInputFile + System.getProperty("line.separator"));
			
			MatrixScanResponse peakResponse = proxy.matrix_scan(matrixScanRequest);
				
			//Results
			String extendedPeakResult = peakResponse.getClient();
			
			List<String> alteredResults = new ArrayList<String>();
			
			//**************************************
			for(String alteredSNPInputFile:alteredSNPInputFiles ){
				String alteredSNPSequence = readAllfromFile(alteredSNPInputFile);
				
				//Set the altered SNP Sequence
				matrixScanRequest.setSequence(alteredSNPSequence);
				
				/*Call the service*/
				//bufferedWriter.write("Matrix-scan: sending request to the server for altered sequences..." + System.getProperty("line.separator"));
				bufferedWriter.write("alteredSequenceFile: "+  alteredSNPInputFile + System.getProperty("line.separator"));
				
				MatrixScanResponse alteredSNPResponse = proxy.matrix_scan(matrixScanRequest);
			
				String alteredSNPResult = alteredSNPResponse.getClient();
				
				alteredResults.add(alteredSNPResult);
			}//for each altered snp sequence file
						
			//**************************************
		
			
			compareResults(referenceResult,alteredResults,extendedPeakResult,bufferedWriter);
			
		
		} catch(Exception e) {
			System.out.println(e.toString());
			
		}

	}

	public static void matrixScan(String outputFolder,String baseDirectory,BufferedWriter bufferedWriter){
		
	
			File baseFolder = new File(outputFolder+baseDirectory);
			File[] files = baseFolder.listFiles();
			
			String snpInputFile = null;
			String alteredSnpInputFile = null;
			List<String> alteredSNPInputFiles = null;
			String peakInputFile = null;
			String pfmMatricesInputFile = null;
			
			String fileName=null;
			String fileAbsolutePath = null;
			
			RSATWebServicesLocator service = new RSATWebServicesLocator();
			RSATWSPortType proxy  = null;
			
			try {
				proxy = service.getRSATWSPortType();
			} catch (ServiceException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			
			MatrixScanRequest matrixScanRequest = new MatrixScanRequest();
						
			 
		    for(File enrichedTfandKeggPathways: files){
		    	
		    	//example	BCL3_hsa03050
		        if(enrichedTfandKeggPathways.isDirectory()) {
		        	
		        	//Initialise input files
	        		pfmMatricesInputFile = null;
	        		
	        		//First get the enriched tf specific pfm matrices file
	        		//First get the pfm matrices input file	 
	        		//example pfmMatrices_BCL3.txt
		        	for (File givenInterval:enrichedTfandKeggPathways.listFiles() ){
		        		if(!givenInterval.isDirectory()){	        		
		        	 			//get the pfmMatrixFile
			        			fileName = givenInterval.getName();
		         				fileAbsolutePath = givenInterval.getAbsolutePath();
		         				
			        			if(fileName.startsWith("pfm")){
		         					pfmMatricesInputFile = fileAbsolutePath;
		         					break;
		         				}
			     		}//End of if			        		
		        	}//End of for
		        	
		        	//Now get the snp specific files
		        	for (File givenInterval:enrichedTfandKeggPathways.listFiles() ){

		        		//we found a given interval directory
		        		//example givenInterval_chr6_170862335_170862335
		        		if(givenInterval.isDirectory()){
		        		  	for(File snps:givenInterval.listFiles()){
		        		  		
		        		  		//example snp_chr6_170862335
				         		if(snps.isDirectory()){
				         			
				         			//Initialise input files
				         			snpInputFile = null;
				         			alteredSnpInputFile = null;
				         			alteredSNPInputFiles = new ArrayList<String>();
				        			peakInputFile = null;
				        				         			
				         			File[] filesforSNPs = snps.listFiles();
				         			
				         			for(File snporPeakorPFMorLogo: filesforSNPs){
				         				
				         				fileName = snporPeakorPFMorLogo.getName();
				         				fileAbsolutePath = snporPeakorPFMorLogo.getAbsolutePath();
				         				
				         				
				         				if (fileName.startsWith("reference")){
				         					snpInputFile = fileAbsolutePath;
				         				}else if (fileName.startsWith("altered")){
				         					alteredSnpInputFile = fileAbsolutePath;
				         					alteredSNPInputFiles.add(alteredSnpInputFile);
				         				}else if (fileName.startsWith("extendedPeak")){
				         					peakInputFile = fileAbsolutePath;
				         				}
				         				 
				         			}//for each necessary file under snp directory
				         			
				         			//If all necessary files are not null
				         			if(snpInputFile!= null && peakInputFile!=null && pfmMatricesInputFile!=null ){
				            			//Matrix Scan Call
					         			matrixScan(snpInputFile,alteredSNPInputFiles,peakInputFile,pfmMatricesInputFile,proxy,matrixScanRequest,bufferedWriter);
					   
				         			}
				         				
				         		}//if it is a directory
				         	}//End of each snp directory
		        			
		        		}//if givenIntervals is directory
		        				        		
		        	}//end of for each givenInterval	         	
		         	
		        }  // if it is a directory
		    }//End of for each enriched tf and kegg pathway directory
		    
			
			
	}
	
	//args[0] must have input file name with folder
	//args[1] must have GLANET installation folder with "" at the end. This folder will be used for outputFolder and dataFolder.
	//args[2] must have Input File Format		
	//args[3] must have Number of Permutations	
	//args[4] must have False Discovery Rate (ex: 0.05)
	//args[5] must have Generate Random Data Mode (with GC and Mapability/without GC and Mapability)
	//args[6] must have writeGeneratedRandomDataMode checkBox
	//args[7] must have writePermutationBasedandParametricBasedAnnotationResultMode checkBox
	//args[8] must have writePermutationBasedAnnotationResultMode checkBox
	//args[9] must have Dnase Enrichment example: DO_DNASE_ENRICHMENT or DO_NOT_DNASE_ENRICHMENT
	//args[10] must have Histone Enrichment example : DO_HISTONE_ENRICHMENT or DO_NOT_HISTONE_ENRICHMENT
	//args[11] must have Tf and KeggPathway Enrichment example: DO_TF_KEGGPATHWAY_ENRICHMENT or DO_NOT_TF_KEGGPATHWAY_ENRICHMENT
	//args[12] must have Tf and CellLine and KeggPathway Enrichment example: DO_TF_CELLLINE_KEGGPATHWAY_ENRICHMENT or DO_NOT_TF_CELLLINE_KEGGPATHWAY_ENRICHMENT
	//args[13] must have a job name exampe: any_string 
	public static void main(String[] args) {
		
		String glanetFolder = args[1];
		String dataFolder 	= glanetFolder + System.getProperty("file.separator") + Commons.DATA + System.getProperty("file.separator") ;
		String outputFolder = glanetFolder + System.getProperty("file.separator") + Commons.OUTPUT + System.getProperty("file.separator") ;
		
		
		String tfExonBasedKeggPathwayBaseDirectory = Commons.TF_EXON_BASED_KEGG_PATHWAY_RESULTS_DIRECTORY_BASE;
		String tfRegulationBasedKeggPathwayBaseDirectory = Commons.TF_REGULATION_BASED_KEGG_PATHWAY_RESULTS_DIRECTORY_BASE;
		String tfAllBasedKeggPathwayBaseDirectory = Commons.TF_ALL_BASED_KEGG_PATHWAY_RESULTS_DIRECTORY_BASE;
		
		
		String tfCellLineExonBasedKeggPathwayBaseDirectory = Commons.TF_CELLLINE_EXON_BASED_KEGG_PATHWAY_RESULTS_DIRECTORY_BASE;
		String tfCellLineRegulationBasedKeggPathwayBaseDirectory = Commons.TF_CELLLINE_REGULATION_BASED_KEGG_PATHWAY_RESULTS_DIRECTORY_BASE;
		String tfCellLineAllBasedKeggPathwayBaseDirectory = Commons.TF_CELLLINE_ALL_BASED_KEGG_PATHWAY_RESULTS_DIRECTORY_BASE;
		
		
		//Delete the results of the former RSAT matrix scan call
		FileOperations.deleteFile(outputFolder,Commons.RSAT_OUTPUT_FILENAME);
		
		FileWriter fileWriter;
		BufferedWriter bufferedWriter;
		try {
			fileWriter = FileOperations.createFileWriter(outputFolder +Commons.RSAT_OUTPUT_FILENAME,true);
			bufferedWriter = new BufferedWriter(fileWriter);
			
			matrixScan(outputFolder,tfExonBasedKeggPathwayBaseDirectory,bufferedWriter);
//			matrixScan(outputFolder,tfRegulationBasedKeggPathwayBaseDirectory,bufferedWriter);
//			matrixScan(outputFolder,tfAllBasedKeggPathwayBaseDirectory,bufferedWriter);
//
//			matrixScan(outputFolder,tfCellLineExonBasedKeggPathwayBaseDirectory,bufferedWriter);
//			matrixScan(outputFolder,tfCellLineRegulationBasedKeggPathwayBaseDirectory,bufferedWriter);
//			matrixScan(outputFolder,tfCellLineAllBasedKeggPathwayBaseDirectory,bufferedWriter);
			
			//Close bufferedWriter
			bufferedWriter.close();
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
				

	}
				

}
